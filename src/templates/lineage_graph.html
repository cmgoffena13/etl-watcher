<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Lineage Graph - Watcher</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .filters {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #666;
        }
        
        .filter-group select, .filter-group input {
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .graph-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            min-height: 600px;
            position: relative;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #666;
        }
        
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d32f2f;
            text-align: center;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node circle {
            stroke: #333;
            stroke-width: 2px;
        }
        
        .node text {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        
        .link.direct {
            stroke: #2196F3;
            stroke-width: 3px;
        }
        
        .link.transitive {
            stroke: #FF9800;
            stroke-dasharray: 5,5;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .tooltip pre {
            margin: 4px 0 0 0;
            padding: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            font-size: 10px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 300px;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px;
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 100;
            min-width: 150px;
        }
        
        .legend h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            height: 16px;
        }
        
        .legend-item:last-child {
            margin-bottom: 0;
        }
        
        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .legend-circle.selected {
            background-color: #FF0000;
        }
        
        .legend-circle.normal {
            background-color: #336791;
        }
        
        .legend-rect {
            width: 16px;
            height: 10px;
            background-color: #90EE90;
            border: 1px solid #4CAF50;
            border-radius: 2px;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .legend-item span {
            font-size: 11px;
            color: #555;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Data Lineage Graph</h1>
        </div>
        
        <div class="filters">
            <div class="filter-group">
                <label>Selected Address</label>
                <select id="selectedAddressFilter">
                    <option value="">Select Address</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Target Address</label>
                <select id="targetAddressFilter" onchange="applyFilters()">
                    <option value="">All Addresses</option>
                </select>
            </div>
            
            
            <div class="filter-group">
                <label>Depth</label>
                <select id="depthFilter" onchange="applyFilters()">
                    <option value="">All Depths</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>Direction</label>
                <select id="directionFilter" onchange="applyFilters()">
                    <option value="both" selected>Both</option>
                    <option value="upstream">Upstream</option>
                    <option value="downstream">Downstream</option>
                </select>
            </div>
            
        </div>
        
        <div class="graph-container">
            <div class="loading" id="loading">Loading lineage graph...</div>
            <div class="error" id="error" style="display: none;"></div>
            <svg id="graph" width="100%" height="600"></svg>
            
            <div class="legend">
                <h4>Legend</h4>
                <div class="legend-item">
                    <div class="legend-circle selected"></div>
                    <span>Selected Address</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle normal"></div>
                    <span>Address</span>
                </div>
                <div class="legend-item">
                    <div class="legend-rect"></div>
                    <span>Pipeline</span>
                </div>
            </div>
        </div>
        
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        let addressesData = null;
        let graphData = null;
        let filteredData = null;

        function showEmptyState() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'none';
            document.getElementById('graph').style.display = 'block';
            
            const svg = d3.select('#graph');
            svg.selectAll('*').remove();
            svg.append('text')
                .attr('x', '50%')
                .attr('y', '50%')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '18px')
                .style('fill', '#666')
                .text('Select an address to view lineage');
        }

        function showLoading(show) {
            if (show) {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';
                document.getElementById('graph').style.display = 'none';
            } else {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('graph').style.display = 'block';
            }
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('graph').style.display = 'none';
            document.getElementById('error').textContent = message;
        }

        async function refreshMaterializedView() {
            try {
                const response = await fetch('/lineage-graph/refresh', {
                    method: 'POST'
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('Failed to refresh materialized view:', error);
            }
        }

        // Initialize page on load
        document.addEventListener('DOMContentLoaded', async function() {
            showEmptyState();
            await loadAddresses();
            await refreshMaterializedView();

            // Listen for changes to the selected address filter
            document.getElementById('selectedAddressFilter').addEventListener('change', async function() {
                const selectedAddress = this.value;
                if (selectedAddress) {
                    const selectedAddressId = getAddressIdByName(selectedAddress);
                    if (selectedAddressId) {
                        await loadGraphData(selectedAddressId);
                        populateDropdowns(graphData, selectedAddressId);
                        applyFilters();
                    } else {
                        showError('Address not found');
                    }
                } else {
                    showEmptyState();
                }
            });
        });

        // Fetch addresses data to populate the selected address dropdown
        async function loadAddresses() {
            try {
                const response = await fetch('/address');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const addresses = await response.json();
                // Store only id and name for efficiency
                addressesData = addresses.map(addr => ({
                    id: addr.id,
                    name: addr.name
                }));
                populateAddresses(addresses);
            } catch (error) {
                showError('Failed to load addresses: ' + error.message);
            }
        }

        async function populateAddresses(addresses) {
            const selectedAddress = document.getElementById('selectedAddressFilter');
            selectedAddress.innerHTML = '<option value="">Select Address</option>';
            // Populate addresses dropdown with address names
            addresses.forEach(address => {
                const option = document.createElement('option');
                option.value = address.name;
                option.textContent = address.name;
                selectedAddress.appendChild(option);
            });
        }

        function getAddressIdByName(addressName) {
            // If no addresses data or it's not an array, return
            if (!addressesData || !Array.isArray(addressesData)) {
                console.error('Addresses data not available');
                return null;
            }
            
            const address = addressesData.find(addr => addr && addr.name === addressName);
            if (!address) {
                console.error(`Address not found: ${addressName}`);
                return null;
            }
            
            if (!address.id || typeof address.id !== 'number') {
                console.error(`Invalid address ID for ${addressName}:`, address.id);
                return null;
            }
            
            return address.id;
        }

        // Once an Address is selected

        // Step1: Load the graph data for the selected address
        async function loadGraphData(selectedAddressId) {
            try {
                showLoading(true);
                const response = await fetch(`/lineage-graph/?source_address_id=${selectedAddressId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                graphData = await response.json();
                showLoading(false);
            } catch (error) {
                showError('Failed to load lineage graph: ' + error.message);
            }
        }

        // Step2: Populate the drop downs with the data from the graph data
        function populateDropdowns(graphData, selectedAddressId) {
            // If no graph data or nodes, return
            if (!graphData || !graphData.nodes) return;

            const selectedTargetAddress = document.getElementById('targetAddressFilter');
            const previouslySelectedTargetAddress = selectedTargetAddress.value; // Save current selection
            selectedTargetAddress.innerHTML = '<option value="">All Addresses</option>';
            
            // Get all target addresses from the edges
            const downstreamTargetAddresses = new Set();
            
            graphData.edges.forEach(edge => {
                downstreamTargetAddresses.add(edge.target_address_id);
            });
            
            // Convert to node names and sort
            const targetAddressNames = Array.from(downstreamTargetAddresses)
                .map(nodeId => graphData.nodes.find(n => n.id === nodeId)?.name)
                .filter(name => name)
                .sort();
            
            // Populate target address dropdown with downstream addresses
            targetAddressNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectedTargetAddress.appendChild(option);
            });
            
            // Restore previous selection if it still exists
            if (previouslySelectedTargetAddress && targetAddressNames.includes(previouslySelectedTargetAddress)) {
                selectedTargetAddress.value = previouslySelectedTargetAddress;
            }
            
            // Populate depth dropdown
            const depthFilter = document.getElementById('depthFilter');
            const previouslySelectedDepth = depthFilter.value;
            depthFilter.innerHTML = '<option value="">All Depths</option>';
            
            // Calculate depths to get available depth options
            const depths = new Map();
            const visited = new Set();
            const queue = [{ node: { id: selectedAddressId }, depth: 0 }];
            depths.set(selectedAddressId, 0);
            visited.add(selectedAddressId);
            
            while (queue.length > 0) {
                const { node, depth } = queue.shift();
                
                graphData.edges.forEach(edge => {
                    let connectedNode = null;
                    if (edge.source_address_id === node.id) {
                        connectedNode = { id: edge.target_address_id };
                    } else if (edge.target_address_id === node.id) {
                        connectedNode = { id: edge.source_address_id };
                    }
                    
                    if (connectedNode && !visited.has(connectedNode.id)) {
                        const newDepth = edge.source_address_id === node.id ? depth + 1 : depth - 1;
                        depths.set(connectedNode.id, newDepth);
                        visited.add(connectedNode.id);
                        queue.push({ node: connectedNode, depth: newDepth });
                    }
                });
            }
            
            // Get unique depths and sort them, excluding depth 0 (center node)
            const uniqueDepths = [...new Set(depths.values())]
                .map(d => Math.abs(d))
                .filter(d => d > 0)  // Exclude depth 0 (center node)
                .sort();
            
            uniqueDepths.forEach(depth => {
                const option = document.createElement('option');
                option.value = depth;
                option.textContent = `Depth ${depth}`;
                if (depth === 2) option.selected = true; // Default to depth 2
                depthFilter.appendChild(option);
            });
            
            // Restore previous selection or set default
            if (previouslySelectedDepth && uniqueDepths.includes(parseInt(previouslySelectedDepth))) {
                depthFilter.value = previouslySelectedDepth;
            } else if (uniqueDepths.includes(2)) {
                depthFilter.value = 2;
            }
        }

        // Step3: Apply the filters to the graph data (also triggered by other dropdowns)
        function applyFilters() {
            if (!graphData) return;
            
            const selectedAddress = document.getElementById('selectedAddressFilter').value;
            const selectedAddressId = getAddressIdByName(selectedAddress);
            const selectedTargetAddress = document.getElementById('targetAddressFilter').value;
            const depthFilter = document.getElementById('depthFilter').value;
            const directionFilter = document.getElementById('directionFilter').value;
            
            // If no center node is selected, show empty state
            if (!selectedAddressId) {
                showEmptyState();
                return;
            }
        
            let nodes = graphData.nodes;
            let edges = graphData.edges;
            
            // Apply target address filter
            if (selectedTargetAddress && selectedTargetAddress !== "") {
                const targetNodeId = getAddressIdByName(selectedTargetAddress);
                if (targetNodeId) {
                    // Find path from selected address to target address
                    const pathEdges = [];
                    const pathNodes = new Set();
                    pathNodes.add(selectedAddressId); // Always include the center
                    pathNodes.add(targetNodeId); // Always include the target
                    
                    // Use BFS to find path from center to target
                    const queue = [{ nodeId: selectedAddressId, path: [] }];
                    const visited = new Set();
                    
                    while (queue.length > 0) {
                        const { nodeId, path } = queue.shift();
                        if (visited.has(nodeId)) continue;
                        visited.add(nodeId);
                        
                        // If we reached the target, add all edges in the path
                        if (nodeId === targetNodeId) {
                            path.forEach(edge => {
                                pathEdges.push(edge);
                                pathNodes.add(edge.source_address_id);
                                pathNodes.add(edge.target_address_id);
                            });
                            break;
                        }
                        
                        // Find all edges from this node
                        edges.forEach(edge => {
                            if (edge.source_address_id === nodeId && !visited.has(edge.target_address_id)) {
                                queue.push({ 
                                    nodeId: edge.target_address_id, 
                                    path: [...path, edge] 
                                });
                            }
                        });
                    }
                    
                    edges = pathEdges;
                    nodes = nodes.filter(node => pathNodes.has(node.id));
                }
            }
            
            // Apply direction filter
            if (directionFilter && directionFilter !== "both" && selectedAddressId) {
                const connectedNodeIds = new Set();
                connectedNodeIds.add(selectedAddressId); // Always include the center node
                
                if (directionFilter === "upstream") {
                    // Find all upstream nodes and edges
                    const upstreamNodes = new Set();
                    const upstreamEdges = [];
                    
                    // Start with direct upstream connections
                    const directUpstream = edges.filter(edge => edge.target_address_id === selectedAddressId);
                    directUpstream.forEach(edge => {
                        upstreamNodes.add(edge.source_address_id);
                        upstreamEdges.push(edge);
                    });
                    
                    // Recursively find all upstream connections
                    let foundNew = true;
                    while (foundNew) {
                        foundNew = false;
                        edges.forEach(edge => {
                            if (upstreamNodes.has(edge.target_address_id) && !upstreamNodes.has(edge.source_address_id)) {
                                upstreamNodes.add(edge.source_address_id);
                                upstreamEdges.push(edge);
                                foundNew = true;
                            }
                        });
                    }
                    
                    edges = upstreamEdges;
                    upstreamNodes.forEach(id => connectedNodeIds.add(id));
                    
                } else if (directionFilter === "downstream") {
                    // Find all downstream nodes and edges
                    const downstreamNodes = new Set();
                    const downstreamEdges = [];
                    
                    // Start with direct downstream connections
                    const directDownstream = edges.filter(edge => edge.source_address_id === selectedAddressId);
                    directDownstream.forEach(edge => {
                        downstreamNodes.add(edge.target_address_id);
                        downstreamEdges.push(edge);
                    });
                    
                    // Recursively find all downstream connections
                    let foundNew = true;
                    while (foundNew) {
                        foundNew = false;
                        edges.forEach(edge => {
                            if (downstreamNodes.has(edge.source_address_id) && !downstreamNodes.has(edge.target_address_id)) {
                                downstreamNodes.add(edge.target_address_id);
                                downstreamEdges.push(edge);
                                foundNew = true;
                            }
                        });
                    }
                    
                    edges = downstreamEdges;
                    downstreamNodes.forEach(id => connectedNodeIds.add(id));
                }
                
                // Filter nodes to only include those in the connected set
                nodes = nodes.filter(node => connectedNodeIds.has(node.id));
            }
            
            // Apply depth filter using the same algorithm as layout
            if (depthFilter && depthFilter !== "" && selectedAddressId) {
                const maxDepth = parseInt(depthFilter);
                
                // Calculate depths using the same BFS as layout
                const depths = new Map();
                const visited = new Set();
                const queue = [{ node: { id: selectedAddressId }, depth: 0 }];
                depths.set(selectedAddressId, 0);
                visited.add(selectedAddressId);
                
                while (queue.length > 0) {
                    const { node, depth } = queue.shift();
                    
                    edges.forEach(edge => {
                        let connectedNode = null;
                        if (edge.source_address_id === node.id) {
                            connectedNode = { id: edge.target_address_id };
                        } else if (edge.target_address_id === node.id) {
                            connectedNode = { id: edge.source_address_id };
                        }
                        
                        if (connectedNode && !visited.has(connectedNode.id)) {
                            const newDepth = edge.source_address_id === node.id ? depth + 1 : depth - 1;
                            depths.set(connectedNode.id, newDepth);
                            visited.add(connectedNode.id);
                            queue.push({ node: connectedNode, depth: newDepth });
                        }
                    });
                }
                
                // Filter edges based on depth
                edges = edges.filter(edge => {
                    const sourceDepth = Math.abs(depths.get(edge.source_address_id) || 0);
                    const targetDepth = Math.abs(depths.get(edge.target_address_id) || 0);
                    return sourceDepth <= maxDepth && targetDepth <= maxDepth;
                });
                
                // Filter nodes to only include those connected by remaining edges
                const connectedNodeIds = new Set();
                connectedNodeIds.add(selectedAddressId);
                edges.forEach(edge => {
                    connectedNodeIds.add(edge.source_address_id);
                    connectedNodeIds.add(edge.target_address_id);
                });
                nodes = nodes.filter(node => connectedNodeIds.has(node.id));
            }
            
            filteredData = {
                nodes: nodes,
                edges: edges
            };
            
            renderGraph();
        }

        // Graph Rendering
        function renderGraph() {
            if (!filteredData) return;
            
            const svg = d3.select('#graph');
            svg.selectAll('*').remove();
            
            // Get the container width or use a default
            const containerWidth = svg.node().parentElement.getBoundingClientRect().width;
            const width = containerWidth > 0 ? containerWidth : 800;
            const height = 600;
            
            svg.attr('width', width).attr('height', height);
            
            const g = svg.append('g');
            
            // Transform edges for D3 force simulation (D3 expects source/target to be node objects)
            const nodeMap = new Map(filteredData.nodes.map(n => [n.id, n]));
            
            const d3Edges = filteredData.edges.map(edge => ({
                ...edge,
                source: nodeMap.get(edge.source_address_id),
                target: nodeMap.get(edge.target_address_id)
            }));
            
            // Calculate hierarchical positions
            const positions = calculateHierarchicalLayout(filteredData.nodes, d3Edges, width, height);
            
            // Apply calculated positions to nodes
            filteredData.nodes.forEach(node => {
                const pos = positions.get(node.id);
                if (pos) {
                    node.x = pos.x;
                    node.y = pos.y;
                    node.fx = pos.x; // Fix position
                    node.fy = pos.y;
                } else {
                    console.warn(`No position calculated for node ${node.id} (${node.name})`);
                }
            });
            
            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(d3Edges)
                .enter().append('line')
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y)
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 2);
            
            // Create pipeline info rectangles on edges
            const pipelineRects = g.append('g')
                .selectAll('rect')
                .data(d3Edges.filter(d => d.pipeline_name)) // Only show for edges with pipeline info
                .enter().append('rect')
                .attr('x', d => (d.source.x + d.target.x) / 2 - 20) // Center on the line
                .attr('y', d => (d.source.y + d.target.y) / 2 - 8)  // Center on the line
                .attr('width', 40)
                .attr('height', 16)
                .attr('fill', '#90EE90') // Light green
                .attr('stroke', '#4CAF50') // Darker green border
                .attr('stroke-width', 1)
                .attr('rx', 3) // Rounded corners
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).style('fill', '#7ED321'); // Darker green on hover
                    const tooltip = d3.select('#tooltip');
                    tooltip.style('display', 'block')
                        .html(`
                            <strong>Pipeline: ${d.pipeline_name || 'Unknown'}</strong><br/>
                            Type: ${d.pipeline_type_name || 'Unknown'}<br/>
                            Active: ${d.pipeline_active ? 'Yes' : 'No'}
                            ${d.pipeline_metadata ? '<br/>Metadata:<br/><pre>' + JSON.stringify(d.pipeline_metadata, null, 2) + '</pre>' : ''}
                        `);
                })
                .on('mousemove', function(event) {
                    d3.select('#tooltip')
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    d3.select('#tooltip').style('display', 'none');
                    d3.select(this).style('fill', '#90EE90'); // Reset to light green
                });
            
            // Add pipeline name text above the rectangles
            const pipelineText = g.append('g')
                .selectAll('text')
                .data(d3Edges.filter(d => d.pipeline_name))
                .enter().append('text')
                .attr('x', d => (d.source.x + d.target.x) / 2)
                .attr('y', d => (d.source.y + d.target.y) / 2 - 14)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#333')
                .text(d => d.pipeline_name);
            
            // Create nodes
            const node = g.append('g')
                .selectAll('g')
                .data(filteredData.nodes)
                .enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            const selectedAddress = document.getElementById('selectedAddressFilter').value;
            
            const circles = node.append('circle')
                .attr('r', 20)
                .attr('fill', d => d.name === selectedAddress ? '#FF0000' : '#336791')
                .attr('stroke', d => d.name === selectedAddress ? '#000000' : '#fff')
                .attr('stroke-width', d => d.name === selectedAddress ? 8 : 2)
                .attr('class', d => d.name === selectedAddress ? 'selected-node' : 'normal-node');
            
            node.append('text')
                .text(d => d.name)
                .attr('dy', -30)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px');
            
            // Add tooltips and click handlers
            node.on('mouseover', function(event, d) {
                const tooltip = d3.select('#tooltip');
                tooltip.style('display', 'block')
                    .html(`
                        <strong>Address: ${d.name}</strong><br/>
                        Type: ${d.address_type_name}<br/>
                        Group: ${d.address_type_group_name}
                        ${d.address_metadata ? '<br/>Metadata:<br/><pre>' + JSON.stringify(d.address_metadata, null, 2) + '</pre>' : ''}
                    `);
            })
            .on('mousemove', function(event) {
                d3.select('#tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function() {
                d3.select('#tooltip').style('display', 'none');
            })
            .on('click', function(event, d) {
                // Set the center node filter to the clicked address
                document.getElementById('selectedAddressFilter').value = d.name;
                // Apply the filters to show lineage for this address
                const selectedAddressId = d.id;
                applyFilters(selectedAddressId);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
                d3.select(this).attr('transform', `translate(${d.fx},${d.fy})`);
            }
            
            function dragended(event, d) {
                d.fx = null;
                d.fy = null;
            }
        }

        function calculateHierarchicalLayout(nodes, edges, width, height) {
            const positions = new Map();
            const nodeMap = new Map();
            nodes.forEach(node => nodeMap.set(node.id, node));
            
            // Find center node (the one selected)
            const centerNodeName = document.getElementById('selectedAddressFilter').value;
            const centerNode = nodes.find(n => n.name === centerNodeName);
            if (!centerNode) {
                return positions;
            }
            
            // Calculate depths from center node using BFS
            const depths = new Map();
            const visited = new Set();
            
            const queue = [{ node: centerNode, depth: 0 }];
            depths.set(centerNode.id, 0);
            visited.add(centerNode.id);
            
            while (queue.length > 0) {
                const { node, depth } = queue.shift();
                
                // Find connected nodes
                edges.forEach(edge => {
                    let connectedNode = null;
                    if (edge.source_address_id === node.id) {
                        connectedNode = nodeMap.get(edge.target_address_id);
                    } else if (edge.target_address_id === node.id) {
                        connectedNode = nodeMap.get(edge.source_address_id);
                    }
                    
                    if (connectedNode && !visited.has(connectedNode.id)) {
                        const newDepth = edge.source_address_id === node.id ? depth + 1 : depth - 1;
                        depths.set(connectedNode.id, newDepth);
                        visited.add(connectedNode.id);
                        queue.push({ node: connectedNode, depth: newDepth });
                    }
                });
            }
            
            // Group nodes by depth
            const depthGroups = new Map();
            nodes.forEach(node => {
                const depth = depths.get(node.id) || 0;
                if (!depthGroups.has(depth)) {
                    depthGroups.set(depth, []);
                }
                depthGroups.get(depth).push(node);
            });
            
            // Calculate positions
            const minDepth = Math.min(...depths.values());
            const maxDepth = Math.max(...depths.values());
            const depthRange = maxDepth - minDepth;
            const xSpacing = depthRange > 0 ? (width - 300) / depthRange : 0; // Leave 150px margin on each side
            const ySpacing = 80;
            
            depthGroups.forEach((groupNodes, depth) => {
                const x = depthRange > 0 ? 150 + (depth - minDepth) * xSpacing : width / 2;
                const startY = (height - (groupNodes.length - 1) * ySpacing) / 2;
                
                groupNodes.forEach((node, index) => {
                    const y = startY + index * ySpacing;
                    positions.set(node.id, { x, y });
                });
            });
            
            
            return positions;
        }

    </script>
</body>
</html>